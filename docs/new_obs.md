# 原设计

目前 rlcard  的 observation 是一个长为 54 的1维数组：

* [0..51]：52位，所有52张牌排序，有手牌+公共牌的地方置1，其它为0

* [52]：我投入的筹码

* [53]：所有人的投入的最大筹码



# 新设计-方案1

现在改成如下设计：

* [0..51]：52位，保持不变，描述手牌+公共牌
* [52..60]：9位，本局玩家人数mask，如6人局即`111111000`
* [61..69]：9位，当前玩家，对应的位置为1
* [70..78]：9位，每个玩家投入的筹码，筹码单位：bb，或采用相对于(最大初始筹码)值
* [79..87]：9位，每个玩家的剩余的筹码，单位与上一致
* [88..92]：5位，合法动作mask，合法的动作对应位置为1，位置含义参考[Action定义][#定义]
* [93..96]：4位，当前阶段，最多4个，参考[Stage定义][#定义]
* 接下来的是动作序列，假设每个阶段每个玩家(最多9个)最多做5次动作，这样我们可以用`shape=(4,5,9,5)`的多维数组来表示完整的打牌过程，这里共需要4x5x9x5=900位

最后成为一个长为997的1维数组。



# 其它考虑

* 不用mask，直接用数值

* 动作序列用紧凑格式，不去填充无效的那些数据，即每个动作由<玩家，阶段，动作值>描述，其中：

  * 玩家：9位
  * 阶段：4位，其含义参考[Stage定义][#定义]
  * 动作值：5位

  由它们构成一个可变长数组，要求网络架构做相应处理。

* 用整数而非位域表示category类型的数据可以减少长度，依赖于网络架构的设计(如用Embedding)。

* 是否要加入equity和pot odds

* 动作空间是否用参数的方式：

  ```python
  action_space = gym.spaces.Dict({
      "action_type": gym.spaces.Discrete(3),
      "bet_size": gym.spaces.Box(low=0, high=1.0, shape=(1,), dtype=np.float32)
  })
  ```

  



# 定义

```python
class Action(IntEnum):
    FOLD = 0
    CHECK_CALL = 1
    RAISE_HALF_POT = 2
    RAISE_POT = 3
    ALL_IN = 4
    
class Stage(IntEnum):
    PREFLOP = 0
    FLOP = 1
    TURN = 2
    RIVER = 3
```

